// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var $$Map = require("bs-platform/lib/js/map.js");
var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Curry = require("bs-platform/lib/js/curry.js");
var React = require("react");
var $$String = require("bs-platform/lib/js/string.js");
var ReactCompat = require("reason-react-compat/src/ReactCompat.bs.js");
var Eval$ReactTemplate = require("./Eval.bs.js");
var SExp$ReactTemplate = require("./SExp.bs.js");
var SExpEditor$ReactTemplate = require("./SExpEditor.bs.js");
var SExpViewer$ReactTemplate = require("./SExpViewer.bs.js");

var StringMap = $$Map.Make({
      compare: $$String.compare
    });

function clear(self) {
  return Curry._1(self.send, /* ClearBuffer */0);
}

function $less$less(self, text) {
  return Curry._1(self.send, {
              TAG: /* AppendBuffer */0,
              _0: text,
              _1: "output"
            });
}

function $great$great(param, callback) {
  return Curry._1(param._0.send, {
              TAG: /* Prompt */1,
              _0: param._1,
              _1: callback
            });
}

function $less$tilde(self, param) {
  return Curry._1(self.send, {
              TAG: /* Define */2,
              _0: param[0],
              _1: param[1]
            });
}

function $percent(self, name) {
  return Curry._2(StringMap.find, name, self.state.mods);
}

function has(self, name) {
  return Curry._2(StringMap.mem, name, self.state.mods);
}

var EvalInstance = Eval$ReactTemplate.Make({
      clear: clear,
      $less$less: $less$less,
      $great$great: $great$great,
      $less$tilde: $less$tilde,
      $percent: $percent,
      has: has
    });

function Terminal$Label(Props) {
  var value = Props.value;
  var clazz = Props.clazz;
  return ReactCompat.useRecordApi({
              willReceiveProps: ReactCompat.component.willReceiveProps,
              willUnmount: ReactCompat.component.willUnmount,
              didUpdate: ReactCompat.component.didUpdate,
              shouldUpdate: ReactCompat.component.shouldUpdate,
              willUpdate: ReactCompat.component.willUpdate,
              didMount: ReactCompat.component.didMount,
              initialState: ReactCompat.component.initialState,
              reducer: ReactCompat.component.reducer,
              render: (function (_self) {
                  return React.createElement("div", {
                              className: $$String.concat("", clazz)
                            }, value);
                })
            });
}

var Label = {
  make: Terminal$Label
};

function Terminal(Props) {
  return ReactCompat.useRecordApi({
              willReceiveProps: ReactCompat.component.willReceiveProps,
              willUnmount: ReactCompat.component.willUnmount,
              didUpdate: ReactCompat.component.didUpdate,
              shouldUpdate: ReactCompat.component.shouldUpdate,
              willUpdate: ReactCompat.component.willUpdate,
              didMount: ReactCompat.component.didMount,
              initialState: (function (param) {
                  return {
                          buffer: /* [] */0,
                          mods: StringMap.empty,
                          minibuffer: SExp$ReactTemplate.empty,
                          prompt: undefined
                        };
                }),
              reducer: (function (action, state) {
                  if (typeof action === "number") {
                    if (action === /* ClearBuffer */0) {
                      return {
                              TAG: /* Update */0,
                              _0: {
                                buffer: /* [] */0,
                                mods: state.mods,
                                minibuffer: state.minibuffer,
                                prompt: state.prompt
                              }
                            };
                    } else {
                      return {
                              TAG: /* UpdateWithSideEffects */2,
                              _0: {
                                buffer: {
                                  hd: {
                                    data: state.minibuffer,
                                    source: "input",
                                    time: new Date()
                                  },
                                  tl: state.buffer
                                },
                                mods: state.mods,
                                minibuffer: SExp$ReactTemplate.empty,
                                prompt: undefined
                              },
                              _1: (function (self) {
                                  var match = state.prompt;
                                  if (match !== undefined) {
                                    return Curry._1(match.handler, state.minibuffer);
                                  }
                                  var exp = Curry._3(EvalInstance.$$eval, self, /* [] */0, state.minibuffer);
                                  if (exp.TAG === /* Result */0) {
                                    return Curry._1(self.send, {
                                                TAG: /* AppendBuffer */0,
                                                _0: exp._0,
                                                _1: "result"
                                              });
                                  } else {
                                    return Curry._1(self.send, {
                                                TAG: /* AppendBuffer */0,
                                                _0: exp._0,
                                                _1: "error"
                                              });
                                  }
                                })
                            };
                    }
                  }
                  switch (action.TAG | 0) {
                    case /* AppendBuffer */0 :
                        return {
                                TAG: /* Update */0,
                                _0: {
                                  buffer: {
                                    hd: {
                                      data: action._0,
                                      source: action._1,
                                      time: new Date()
                                    },
                                    tl: state.buffer
                                  },
                                  mods: state.mods,
                                  minibuffer: state.minibuffer,
                                  prompt: state.prompt
                                }
                              };
                    case /* Prompt */1 :
                        return {
                                TAG: /* Update */0,
                                _0: {
                                  buffer: state.buffer,
                                  mods: state.mods,
                                  minibuffer: state.minibuffer,
                                  prompt: {
                                    indicator: action._0,
                                    handler: action._1
                                  }
                                }
                              };
                    case /* Define */2 :
                        return {
                                TAG: /* Update */0,
                                _0: {
                                  buffer: state.buffer,
                                  mods: Curry._3(StringMap.add, action._0, action._1, state.mods),
                                  minibuffer: state.minibuffer,
                                  prompt: state.prompt
                                }
                              };
                    case /* Update */3 :
                        return {
                                TAG: /* Update */0,
                                _0: {
                                  buffer: state.buffer,
                                  mods: state.mods,
                                  minibuffer: action._0,
                                  prompt: state.prompt
                                }
                              };
                    
                  }
                }),
              render: (function (self) {
                  var match = self.state;
                  var prompt = match.prompt;
                  var buffer = match.buffer;
                  var length = List.length(buffer);
                  return React.createElement("div", {
                              className: "terminal"
                            }, React.createElement("div", {
                                  className: "buffer"
                                }, $$Array.of_list(List.mapi((function (i, param) {
                                            var datax = param.data;
                                            return React.createElement("div", {
                                                        key: String(length - i | 0),
                                                        className: "log " + param.source
                                                      }, React.createElement(Terminal$Label, {
                                                            value: param.time.toLocaleString(),
                                                            clazz: {
                                                              hd: "time",
                                                              tl: /* [] */0
                                                            }
                                                          }), React.createElement(Terminal$Label, {
                                                            value: SExp$ReactTemplate.toString(datax),
                                                            clazz: {
                                                              hd: "source",
                                                              tl: /* [] */0
                                                            }
                                                          }), React.createElement(SExpViewer$ReactTemplate.make, {
                                                            data: datax
                                                          }));
                                          }), buffer))), React.createElement("div", {
                                  className: "mini-buffer"
                                }, prompt !== undefined ? React.createElement(Terminal$Label, {
                                        value: prompt.indicator,
                                        clazz: {
                                          hd: "indicator",
                                          tl: /* [] */0
                                        }
                                      }) : null, React.createElement(SExpEditor$ReactTemplate.make, {
                                      data: match.minibuffer,
                                      onUpdate: (function (data) {
                                          return Curry._1(self.send, {
                                                      TAG: /* Update */3,
                                                      _0: data
                                                    });
                                        })
                                    }), React.createElement("button", {
                                      onClick: (function (param) {
                                          return Curry._1(self.send, /* Execute */1);
                                        })
                                    }, "eval")));
                })
            });
}

var make = Terminal;

exports.StringMap = StringMap;
exports.EvalInstance = EvalInstance;
exports.Label = Label;
exports.make = make;
/* StringMap Not a pure module */
