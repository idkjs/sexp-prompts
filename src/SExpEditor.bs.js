// Generated by BUCKLESCRIPT VERSION 3.0.0, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var React = require("react");
var $$String = require("bs-platform/lib/js/string.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var ReasonReact = require("reason-react/src/ReasonReact.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var SExp$ReactTemplate = require("./SExp.bs.js");
var ContentEditable$ReactTemplate = require("./ContentEditable.bs.js");

function directionToString(param) {
  switch (param) {
    case 0 : 
        return "Current";
    case 1 : 
        return "Backward";
    case 2 : 
        return "Forward";
    
  }
}

function pathListToString(path) {
  var x = $$String.concat(":", List.map((function (prim) {
              return String(prim);
            }), path));
  return "[" + (x + "]");
}

function pathToString(param) {
  if (typeof param === "number") {
    return "root";
  } else if (param.tag) {
    return "relative " + (pathListToString(param[0]) + ("@" + directionToString(param[1])));
  } else {
    return "simple " + pathListToString(param[0]);
  }
}

function simplifyPath(context, param) {
  if (typeof param === "number") {
    return /* [] */0;
  } else if (param.tag) {
    var dir = param[1];
    var _prev = /* [] */0;
    var _param = /* tuple */[
      List.rev(param[0]),
      context
    ];
    while(true) {
      var param$1 = _param;
      var prev = _prev;
      var match = param$1[0];
      if (match) {
        var rest = match[1];
        var pos = match[0];
        if (rest) {
          var match$1 = param$1[1];
          if (match$1.tag) {
            var list = match$1[0];
            if (List.length(list) > pos) {
              _param = /* tuple */[
                rest,
                List.nth(list, pos)
              ];
              _prev = /* :: */[
                pos,
                prev
              ];
              continue ;
            } else {
              return prev;
            }
          } else {
            return prev;
          }
        } else {
          var match$2 = param$1[1];
          if (match$2.tag) {
            var list$1 = match$2[0];
            if (dir === /* Current */0 && List.length(list$1) > pos) {
              return /* :: */[
                      pos,
                      prev
                    ];
            } else if (dir === /* Forward */2 && List.length(list$1) > (pos + 1 | 0)) {
              return /* :: */[
                      pos + 1 | 0,
                      prev
                    ];
            } else if (dir === /* Backward */1 && pos === 0 || dir !== /* Backward */1) {
              return prev;
            } else {
              return /* :: */[
                      pos - 1 | 0,
                      prev
                    ];
            }
          } else {
            return prev;
          }
        }
      } else {
        return prev;
      }
    };
  } else {
    return param[0];
  }
}

var Overflow = Caml_exceptions.create("SExpEditor-ReactTemplate.Overflow");

var InvalidPath = Caml_exceptions.create("SExpEditor-ReactTemplate.InvalidPath");

var component = ReasonReact.reducerComponent("SExpEditor");

function getValue($$event) {
  return $$event.target.value;
}

function getValueByFocus($$event) {
  return $$event.target.innerText;
}

function getValueByKeyboard($$event) {
  return $$event.target.innerText;
}

var doFocus = (
    function (choice, e) {
      if (e) {
        if (choice)
          e.focus();
        e.tabIndex=0;
      }
    }
  );

var selectAll = (
    function (event) {
      const self = event.target;
      const selection = window.getSelection();
      const range = document.createRange();
      range.selectNodeContents(self);
      selection.removeAllRanges();
      selection.addRange(range);
    }
  );

function insertList(item, pos, list) {
  var _prev = /* [] */0;
  var _param = /* tuple */[
    pos,
    list
  ];
  while(true) {
    var param = _param;
    var prev = _prev;
    var n = param[0];
    if (n !== 0) {
      var match = param[1];
      if (match) {
        _param = /* tuple */[
          n - 1 | 0,
          match[1]
        ];
        _prev = /* :: */[
          match[0],
          prev
        ];
        continue ;
      } else {
        throw Overflow;
      }
    } else {
      return Pervasives.$at(List.rev(prev), /* :: */[
                  item,
                  param[1]
                ]);
    }
  };
}

function removeFromList(pos, list) {
  var _prev = /* [] */0;
  var _param = /* tuple */[
    pos,
    list
  ];
  while(true) {
    var param = _param;
    var prev = _prev;
    var n = param[0];
    if (param[1]) {
      if (n !== 0) {
        var match = param[1];
        _param = /* tuple */[
          n - 1 | 0,
          match[1]
        ];
        _prev = /* :: */[
          match[0],
          prev
        ];
        continue ;
      } else {
        return Pervasives.$at(List.rev(prev), param[1][1]);
      }
    } else {
      throw Overflow;
    }
  };
}

function pureDebug(msgfn, thing) {
  console.log(Curry._1(msgfn, thing));
  return thing;
}

function actionDump(param) {
  switch (param.tag | 0) {
    case 0 : 
        return "Select " + pathToString(param[0]);
    case 1 : 
        return "Append " + (pathToString(param[0]) + (" " + directionToString(param[1])));
    case 2 : 
        return "AppendWithNil " + (pathToString(param[0]) + (" " + directionToString(param[1])));
    case 3 : 
        return "Delete " + (pathToString(param[0]) + (" " + directionToString(param[1])));
    case 4 : 
        return "Package " + pathToString(param[0]);
    case 5 : 
        return "Unpackage " + pathToString(param[0]);
    case 6 : 
        return "AsNil " + pathToString(param[0]);
    case 7 : 
        return "Modify " + (pathToString(param[0]) + (": " + param[1]));
    
  }
}

function make(data, onUpdate, _) {
  return /* record */[
          /* debugName */component[/* debugName */0],
          /* reactClassInternal */component[/* reactClassInternal */1],
          /* handedOffState */component[/* handedOffState */2],
          /* willReceiveProps */component[/* willReceiveProps */3],
          /* didMount */component[/* didMount */4],
          /* didUpdate */component[/* didUpdate */5],
          /* willUnmount */component[/* willUnmount */6],
          /* willUpdate */component[/* willUpdate */7],
          /* shouldUpdate */component[/* shouldUpdate */8],
          /* render */(function (self) {
              var path = simplifyPath(data, self[/* state */1][/* select */0]);
              var handleFocus = function (path, $$event) {
                $$event.stopPropagation();
                return Curry._1(self[/* send */3], /* Select */Block.__(0, [/* SimplePath */Block.__(0, [path])]));
              };
              var handleKeydown = function (path, $$event) {
                $$event.stopPropagation();
                var match = $$event.keyCode;
                var match$1 = $$event.ctrlKey;
                if (match !== 13) {
                  if (match !== 32) {
                    return /* () */0;
                  } else if (match$1) {
                    Curry._1(self[/* send */3], /* Append */Block.__(1, [
                            /* SimplePath */Block.__(0, [path]),
                            /* Backward */1
                          ]));
                    $$event.preventDefault();
                    return /* () */0;
                  } else {
                    Curry._1(self[/* send */3], /* Append */Block.__(1, [
                            /* SimplePath */Block.__(0, [path]),
                            /* Forward */2
                          ]));
                    $$event.preventDefault();
                    return /* () */0;
                  }
                } else {
                  Curry._1(self[/* send */3], /* Package */Block.__(4, [/* SimplePath */Block.__(0, [path])]));
                  $$event.preventDefault();
                  return /* () */0;
                }
              };
              var handleKeyup = function (path, $$event) {
                $$event.stopPropagation();
                var match = $$event.keyCode;
                if (match >= 38) {
                  if (match >= 47) {
                    return /* () */0;
                  } else {
                    switch (match - 38 | 0) {
                      case 0 : 
                          Curry._1(self[/* send */3], /* Select */Block.__(0, [/* RelativePath */Block.__(1, [
                                      path,
                                      /* Backward */1
                                    ])]));
                          $$event.preventDefault();
                          return /* () */0;
                      case 2 : 
                          Curry._1(self[/* send */3], /* Select */Block.__(0, [/* RelativePath */Block.__(1, [
                                      path,
                                      /* Forward */2
                                    ])]));
                          $$event.preventDefault();
                          return /* () */0;
                      case 1 : 
                      case 3 : 
                      case 4 : 
                      case 5 : 
                      case 6 : 
                      case 7 : 
                          return /* () */0;
                      case 8 : 
                          Curry._1(self[/* send */3], /* Delete */Block.__(3, [
                                  /* SimplePath */Block.__(0, [path]),
                                  /* Forward */2
                                ]));
                          $$event.preventDefault();
                          return /* () */0;
                      
                    }
                  }
                } else if (match !== 8) {
                  return /* () */0;
                } else {
                  Curry._1(self[/* send */3], /* Delete */Block.__(3, [
                          /* SimplePath */Block.__(0, [path]),
                          /* Backward */1
                        ]));
                  $$event.preventDefault();
                  return /* () */0;
                }
              };
              var renderList = function (xpath, list) {
                var handleListKeyup = function ($$event) {
                  $$event.stopPropagation();
                  var match = $$event.shiftKey;
                  var match$1 = $$event.keyCode;
                  if (match && match$1 === 8) {
                    Curry._1(self[/* send */3], /* Unpackage */Block.__(5, [/* SimplePath */Block.__(0, [xpath])]));
                    $$event.preventDefault();
                    return /* () */0;
                  } else {
                    return handleKeyup(xpath, $$event);
                  }
                };
                return React.createElement("span", {
                            ref: Curry._1(doFocus, Caml_obj.caml_equal(path, xpath)),
                            className: "list",
                            onKeyDown: (function (param) {
                                return handleKeydown(xpath, param);
                              }),
                            onKeyUp: handleListKeyup,
                            onFocus: (function (param) {
                                return handleFocus(xpath, param);
                              })
                          }, $$Array.of_list(List.mapi((function (i, item) {
                                      var clazz;
                                      clazz = !item.tag || item[0] ? "item" : "item item-nil";
                                      return React.createElement("div", {
                                                  key: String(i),
                                                  className: clazz
                                                }, renderSExp(/* :: */[
                                                      i,
                                                      xpath
                                                    ], item));
                                    }), list)));
              };
              var renderSExp = function (xpath, param) {
                var exit = 0;
                var special;
                var content;
                if (param.tag) {
                  var list = param[0];
                  if (list) {
                    var match = list[0];
                    if (match.tag) {
                      return renderList(xpath, list);
                    } else {
                      var special$1 = match[0];
                      switch (special$1) {
                        case "quote" : 
                            var match$1 = list[1];
                            if (match$1 && !match$1[1]) {
                              special = special$1;
                              content = match$1[0];
                              exit = 1;
                            } else {
                              return renderList(xpath, list);
                            }
                            break;
                        case "string" : 
                            var match$2 = list[1];
                            if (match$2) {
                              var content$1 = match$2[0];
                              if (content$1.tag && !match$2[1]) {
                                special = special$1;
                                content = content$1;
                                exit = 1;
                              } else {
                                return renderList(xpath, list);
                              }
                            } else {
                              return renderList(xpath, list);
                            }
                            break;
                        default:
                          return renderList(xpath, list);
                      }
                    }
                  } else {
                    return React.createElement("span", {
                                ref: Curry._1(doFocus, Caml_obj.caml_equal(path, xpath)),
                                className: "nil",
                                onKeyDown: (function (param) {
                                    return handleKeydown(xpath, param);
                                  }),
                                onKeyUp: (function (param) {
                                    return handleKeyup(xpath, param);
                                  }),
                                onFocus: (function (param) {
                                    return handleFocus(xpath, param);
                                  })
                              });
                  }
                } else {
                  var xpath$1 = xpath;
                  var value = param[0];
                  var handleInputKeyup = function ($$event) {
                    $$event.stopPropagation();
                    var match = $$event.target.innerText;
                    var match$1 = $$event.keyCode;
                    var exit = 0;
                    var switcher = match$1 - 38 | 0;
                    if (switcher > 2 || switcher < 0) {
                      exit = 1;
                    } else {
                      switch (switcher) {
                        case 0 : 
                            Curry._1(self[/* send */3], /* Select */Block.__(0, [/* RelativePath */Block.__(1, [
                                        path,
                                        /* Backward */1
                                      ])]));
                            $$event.preventDefault();
                            return /* () */0;
                        case 1 : 
                            exit = 1;
                            break;
                        case 2 : 
                            Curry._1(self[/* send */3], /* Select */Block.__(0, [/* RelativePath */Block.__(1, [
                                        path,
                                        /* Forward */2
                                      ])]));
                            $$event.preventDefault();
                            return /* () */0;
                        
                      }
                    }
                    if (exit === 1) {
                      if (match === "") {
                        return handleKeyup(xpath$1, $$event);
                      } else {
                        return /* () */0;
                      }
                    }
                    
                  };
                  var handleInputKeydown = function ($$event) {
                    $$event.stopPropagation();
                    var match = $$event.target.innerText;
                    var match$1 = $$event.keyCode;
                    var match$2 = $$event.key;
                    var exit = 0;
                    var exit$1 = 0;
                    switch (match$2) {
                      case "(" : 
                      case ")" : 
                          $$event.preventDefault();
                          return /* () */0;
                      default:
                        var switcher = match$1 - 38 | 0;
                        if (switcher > 2 || switcher < 0) {
                          if (switcher !== -25) {
                            exit$1 = 2;
                          } else {
                            Curry._1(self[/* send */3], /* Package */Block.__(4, [/* SimplePath */Block.__(0, [path])]));
                            $$event.preventDefault();
                            return /* () */0;
                          }
                        } else if (switcher !== 1) {
                          $$event.preventDefault();
                          return /* () */0;
                        } else {
                          exit$1 = 2;
                        }
                    }
                    if (exit$1 === 2) {
                      if (match === "" && match$1 === 32) {
                        var match$3 = $$event.ctrlKey;
                        Curry._1(self[/* send */3], /* AppendWithNil */Block.__(2, [
                                /* SimplePath */Block.__(0, [path]),
                                match$3 ? /* Backward */1 : /* Forward */2
                              ]));
                        $$event.preventDefault();
                        return /* () */0;
                      } else {
                        exit = 1;
                      }
                    }
                    if (exit === 1) {
                      if (match$1 !== 32) {
                        return /* () */0;
                      } else {
                        var match$4 = $$event.ctrlKey;
                        Curry._1(self[/* send */3], /* Append */Block.__(1, [
                                /* SimplePath */Block.__(0, [path]),
                                match$4 ? /* Backward */1 : /* Forward */2
                              ]));
                        $$event.preventDefault();
                        return /* () */0;
                      }
                    }
                    
                  };
                  var handleBlur = function ($$event) {
                    var match = $$event.target.innerText;
                    if (match === "" && Caml_obj.caml_equal(path, xpath$1)) {
                      return Curry._1(self[/* send */3], /* Delete */Block.__(3, [
                                    /* SimplePath */Block.__(0, [path]),
                                    /* Backward */1
                                  ]));
                    } else {
                      return /* () */0;
                    }
                  };
                  var handleChange = function ($$event) {
                    return Curry._1(self[/* send */3], /* Modify */Block.__(7, [
                                  /* SimplePath */Block.__(0, [xpath$1]),
                                  $$event.target.value
                                ]));
                  };
                  var handleInputFocus = function ($$event) {
                    Curry._1(selectAll, $$event);
                    return handleFocus(xpath$1, $$event);
                  };
                  return ReasonReact.element(/* None */0, /* None */0, ContentEditable$ReactTemplate.make(value, Caml_obj.caml_equal(path, xpath$1), "atom editor", handleChange, handleInputKeyup, handleInputKeydown, handleBlur, handleInputFocus, /* array */[]));
                }
                if (exit === 1) {
                  return React.createElement("span", {
                              ref: Curry._1(doFocus, Caml_obj.caml_equal(path, xpath)),
                              className: special,
                              onKeyDown: (function (param) {
                                  return handleKeydown(xpath, param);
                                }),
                              onKeyUp: (function (param) {
                                  return handleKeyup(xpath, param);
                                }),
                              onFocus: (function (param) {
                                  return handleFocus(xpath, param);
                                })
                            }, renderSExp(/* :: */[
                                  1,
                                  xpath
                                ], content));
                }
                
              };
              return renderSExp(/* [] */0, data);
            }),
          /* initialState */(function () {
              return /* record */[/* select : RootPath */0];
            }),
          /* retainedProps */component[/* retainedProps */11],
          /* reducer */(function (action, _) {
              console.log(actionDump(action));
              var handleUpdate = function (param) {
                switch (param.tag | 0) {
                  case 0 : 
                      return /* Update */Block.__(0, [/* record */[/* select */param[0]]]);
                  case 1 : 
                      var expr = param[0];
                      return /* SideEffects */Block.__(1, [(function () {
                                    return Curry._1(onUpdate, expr);
                                  })]);
                  case 2 : 
                      var expr$1 = param[1];
                      return /* UpdateWithSideEffects */Block.__(2, [
                                /* record */[/* select */param[0]],
                                (function () {
                                    return Curry._1(onUpdate, expr$1);
                                  })
                              ]);
                  
                }
              };
              switch (action.tag | 0) {
                case 0 : 
                    return handleUpdate(/* CleanUpdate */Block.__(0, [action[0]]));
                case 1 : 
                    var direction = action[1];
                    var path = action[0];
                    var spath = List.rev(simplifyPath(data, path));
                    var access = function (_fn, _param) {
                      while(true) {
                        var param = _param;
                        var fn = _fn;
                        var match = param[0];
                        if (match) {
                          var next = match[1];
                          var pos = match[0];
                          if (next) {
                            var match$1 = param[1];
                            if (match$1.tag) {
                              var list = match$1[0];
                              _param = /* tuple */[
                                next,
                                List.nth(list, pos),
                                /* :: */[
                                  pos,
                                  param[2]
                                ]
                              ];
                              _fn = (function(fn,pos,list){
                              return function (newitem) {
                                return Curry._1(fn, /* List */Block.__(1, [List.mapi((function (i, item) {
                                                      if (i === pos) {
                                                        return newitem;
                                                      } else {
                                                        return item;
                                                      }
                                                    }), list)]));
                              }
                              }(fn,pos,list));
                              continue ;
                            } else {
                              throw [
                                    InvalidPath,
                                    path
                                  ];
                            }
                          } else {
                            var match$2 = param[1];
                            if (match$2.tag) {
                              var prev = param[2];
                              var list$1 = match$2[0];
                              if (direction >= 2) {
                                return /* tuple */[
                                        Curry._1(fn, /* List */Block.__(1, [insertList(/* Atom */Block.__(0, [""]), pos + 1 | 0, list$1)])),
                                        /* SimplePath */Block.__(0, [/* :: */[
                                              pos + 1 | 0,
                                              prev
                                            ]])
                                      ];
                              } else {
                                return /* tuple */[
                                        Curry._1(fn, /* List */Block.__(1, [insertList(/* Atom */Block.__(0, [""]), pos, list$1)])),
                                        /* SimplePath */Block.__(0, [/* :: */[
                                              pos,
                                              prev
                                            ]])
                                      ];
                              }
                            } else {
                              throw [
                                    InvalidPath,
                                    path
                                  ];
                            }
                          }
                        } else {
                          var match$3 = param[1];
                          if (match$3.tag) {
                            var list$2 = match$3[0];
                            if (list$2) {
                              if (param[2]) {
                                throw [
                                      InvalidPath,
                                      path
                                    ];
                              } else {
                                return /* tuple */[
                                        Curry._1(fn, /* List */Block.__(1, [/* :: */[
                                                  /* Atom */Block.__(0, [""]),
                                                  list$2
                                                ]])),
                                        /* SimplePath */Block.__(0, [/* :: */[
                                              0,
                                              /* [] */0
                                            ]])
                                      ];
                              }
                            } else if (param[2]) {
                              throw [
                                    InvalidPath,
                                    path
                                  ];
                            } else {
                              return /* tuple */[
                                      Curry._1(fn, /* List */Block.__(1, [/* :: */[
                                                /* Atom */Block.__(0, [""]),
                                                /* [] */0
                                              ]])),
                                      /* SimplePath */Block.__(0, [/* :: */[
                                            0,
                                            /* [] */0
                                          ]])
                                    ];
                            }
                          } else if (param[2]) {
                            throw [
                                  InvalidPath,
                                  path
                                ];
                          } else {
                            return /* tuple */[
                                    Curry._1(fn, /* List */Block.__(1, [/* :: */[
                                              /* Atom */Block.__(0, [match$3[0]]),
                                              /* [] */0
                                            ]])),
                                    /* SimplePath */Block.__(0, [/* :: */[
                                          0,
                                          /* [] */0
                                        ]])
                                  ];
                          }
                        }
                      };
                    };
                    var match = access((function (x) {
                            return x;
                          }), /* tuple */[
                          spath,
                          data,
                          /* [] */0
                        ]);
                    return handleUpdate(/* MixUpdate */Block.__(2, [
                                  match[1],
                                  match[0]
                                ]));
                case 2 : 
                    var direction$1 = action[1];
                    var path$1 = action[0];
                    var spath$1 = List.rev(simplifyPath(data, path$1));
                    var access$1 = function (_fn, _param) {
                      while(true) {
                        var param = _param;
                        var fn = _fn;
                        var match = param[0];
                        if (match) {
                          var next = match[1];
                          var pos = match[0];
                          if (next) {
                            var match$1 = param[1];
                            if (match$1.tag) {
                              var list = match$1[0];
                              _param = /* tuple */[
                                next,
                                List.nth(list, pos),
                                /* :: */[
                                  pos,
                                  param[2]
                                ]
                              ];
                              _fn = (function(fn,pos,list){
                              return function (newitem) {
                                return Curry._1(fn, /* List */Block.__(1, [List.mapi((function (i, item) {
                                                      if (i === pos) {
                                                        return newitem;
                                                      } else {
                                                        return item;
                                                      }
                                                    }), list)]));
                              }
                              }(fn,pos,list));
                              continue ;
                            } else {
                              throw [
                                    InvalidPath,
                                    path$1
                                  ];
                            }
                          } else {
                            var match$2 = param[1];
                            if (match$2.tag) {
                              var match$3 = direction$1 === /* Forward */2;
                              var xpos = match$3 ? pos + 1 | 0 : pos;
                              return /* tuple */[
                                      Curry._1(fn, /* List */Block.__(1, [insertList(/* Atom */Block.__(0, [""]), xpos, List.mapi((function(pos){
                                                      return function (i, item) {
                                                        if (i === pos) {
                                                          return SExp$ReactTemplate.empty;
                                                        } else {
                                                          return item;
                                                        }
                                                      }
                                                      }(pos)), match$2[0]))])),
                                      /* SimplePath */Block.__(0, [/* :: */[
                                            xpos,
                                            param[2]
                                          ]])
                                    ];
                            } else {
                              throw [
                                    InvalidPath,
                                    path$1
                                  ];
                            }
                          }
                        } else {
                          var match$4 = param[1];
                          if (match$4.tag) {
                            var list$1 = match$4[0];
                            if (list$1) {
                              if (param[2]) {
                                throw [
                                      InvalidPath,
                                      path$1
                                    ];
                              } else {
                                return /* tuple */[
                                        Curry._1(fn, /* List */Block.__(1, [/* :: */[
                                                  /* Atom */Block.__(0, [""]),
                                                  list$1
                                                ]])),
                                        /* SimplePath */Block.__(0, [/* :: */[
                                              0,
                                              /* [] */0
                                            ]])
                                      ];
                              }
                            } else if (param[2]) {
                              throw [
                                    InvalidPath,
                                    path$1
                                  ];
                            } else {
                              return /* tuple */[
                                      Curry._1(fn, /* List */Block.__(1, [/* :: */[
                                                /* Atom */Block.__(0, [""]),
                                                /* [] */0
                                              ]])),
                                      /* SimplePath */Block.__(0, [/* :: */[
                                            0,
                                            /* [] */0
                                          ]])
                                    ];
                            }
                          } else if (param[2]) {
                            throw [
                                  InvalidPath,
                                  path$1
                                ];
                          } else {
                            return /* tuple */[
                                    Curry._1(fn, /* List */Block.__(1, [/* :: */[
                                              /* Atom */Block.__(0, [match$4[0]]),
                                              /* [] */0
                                            ]])),
                                    /* SimplePath */Block.__(0, [/* :: */[
                                          0,
                                          /* [] */0
                                        ]])
                                  ];
                          }
                        }
                      };
                    };
                    var match$1 = access$1((function (x) {
                            return x;
                          }), /* tuple */[
                          spath$1,
                          data,
                          /* [] */0
                        ]);
                    return handleUpdate(/* MixUpdate */Block.__(2, [
                                  match$1[1],
                                  match$1[0]
                                ]));
                case 3 : 
                    var dir = action[1];
                    var path$2 = action[0];
                    var spath$2 = List.rev(simplifyPath(data, path$2));
                    var access$2 = function (_fn, _param) {
                      while(true) {
                        var param = _param;
                        var fn = _fn;
                        var match = param[0];
                        if (match) {
                          var next = match[1];
                          var pos = match[0];
                          if (next) {
                            var match$1 = param[1];
                            if (match$1.tag) {
                              var list = match$1[0];
                              _param = /* tuple */[
                                next,
                                List.nth(list, pos)
                              ];
                              _fn = (function(fn,pos,list){
                              return function (newitem) {
                                return Curry._1(fn, /* List */Block.__(1, [List.mapi((function (i, item) {
                                                      if (i === pos) {
                                                        return newitem;
                                                      } else {
                                                        return item;
                                                      }
                                                    }), list)]));
                              }
                              }(fn,pos,list));
                              continue ;
                            } else {
                              throw [
                                    InvalidPath,
                                    path$2
                                  ];
                            }
                          } else {
                            var list$1 = param[1];
                            if (list$1.tag) {
                              var list$2 = list$1[0];
                              if (List.length(list$2) > pos) {
                                var match$2 = dir === /* Backward */1;
                                return /* tuple */[
                                        Curry._1(fn, /* List */Block.__(1, [removeFromList(pos, list$2)])),
                                        match$2 ? /* RelativePath */Block.__(1, [
                                              List.rev(spath$2),
                                              /* Backward */1
                                            ]) : /* RelativePath */Block.__(1, [
                                              List.rev(spath$2),
                                              /* Current */0
                                            ])
                                      ];
                              } else {
                                return /* tuple */[
                                        Curry._1(fn, list$1),
                                        /* SimplePath */Block.__(0, [List.rev(spath$2)])
                                      ];
                              }
                            } else {
                              throw [
                                    InvalidPath,
                                    path$2
                                  ];
                            }
                          }
                        } else {
                          var src = param[1];
                          if (src.tag) {
                            return /* tuple */[
                                    Curry._1(fn, src),
                                    /* RootPath */0
                                  ];
                          } else {
                            return /* tuple */[
                                    Curry._1(fn, /* List */Block.__(1, [/* [] */0])),
                                    /* RootPath */0
                                  ];
                          }
                        }
                      };
                    };
                    var match$2 = access$2((function (x) {
                            return x;
                          }), /* tuple */[
                          spath$2,
                          data
                        ]);
                    return handleUpdate(/* MixUpdate */Block.__(2, [
                                  match$2[1],
                                  match$2[0]
                                ]));
                case 4 : 
                    var path$3 = action[0];
                    var spath$3 = List.rev(simplifyPath(data, path$3));
                    var access$3 = function (_fn, _param) {
                      while(true) {
                        var param = _param;
                        var fn = _fn;
                        var match = param[0];
                        if (match) {
                          var match$1 = param[1];
                          var pos = match[0];
                          if (match$1.tag) {
                            var list = match$1[0];
                            _param = /* tuple */[
                              match[1],
                              List.nth(list, pos),
                              /* :: */[
                                pos,
                                param[2]
                              ]
                            ];
                            _fn = (function(fn,pos,list){
                            return function (newitem) {
                              return Curry._1(fn, /* List */Block.__(1, [List.mapi((function (i, item) {
                                                    if (i === pos) {
                                                      return newitem;
                                                    } else {
                                                      return item;
                                                    }
                                                  }), list)]));
                            }
                            }(fn,pos,list));
                            continue ;
                          } else {
                            throw [
                                  InvalidPath,
                                  path$3
                                ];
                          }
                        } else {
                          var src = param[1];
                          var exit = 0;
                          if (src.tag) {
                            if (src[0]) {
                              exit = 1;
                            } else {
                              return /* tuple */[
                                      Curry._1(fn, /* List */Block.__(1, [/* :: */[
                                                /* Atom */Block.__(0, [""]),
                                                /* [] */0
                                              ]])),
                                      /* SimplePath */Block.__(0, [/* :: */[
                                            0,
                                            param[2]
                                          ]])
                                    ];
                            }
                          } else if (src[0] === "") {
                            return /* tuple */[
                                    Curry._1(fn, /* List */Block.__(1, [/* :: */[
                                              /* Atom */Block.__(0, [""]),
                                              /* [] */0
                                            ]])),
                                    /* SimplePath */Block.__(0, [/* :: */[
                                          0,
                                          param[2]
                                        ]])
                                  ];
                          } else {
                            exit = 1;
                          }
                          if (exit === 1) {
                            return /* tuple */[
                                    Curry._1(fn, /* List */Block.__(1, [/* :: */[
                                              src,
                                              /* :: */[
                                                /* Atom */Block.__(0, [""]),
                                                /* [] */0
                                              ]
                                            ]])),
                                    /* SimplePath */Block.__(0, [/* :: */[
                                          1,
                                          param[2]
                                        ]])
                                  ];
                          }
                          
                        }
                      };
                    };
                    var match$3 = access$3((function (x) {
                            return x;
                          }), /* tuple */[
                          spath$3,
                          data,
                          /* [] */0
                        ]);
                    return handleUpdate(/* MixUpdate */Block.__(2, [
                                  match$3[1],
                                  match$3[0]
                                ]));
                case 5 : 
                    var path$4 = action[0];
                    var spath$4 = List.rev(simplifyPath(data, path$4));
                    var access$4 = function (_fn, _param) {
                      while(true) {
                        var param = _param;
                        var fn = _fn;
                        var match = param[0];
                        if (match) {
                          var next = match[1];
                          var pos = match[0];
                          if (next) {
                            var match$1 = param[1];
                            if (match$1.tag) {
                              var list = match$1[0];
                              _param = /* tuple */[
                                next,
                                List.nth(list, pos)
                              ];
                              _fn = (function(fn,pos,list){
                              return function (newitem) {
                                return Curry._1(fn, /* List */Block.__(1, [List.mapi((function (i, item) {
                                                      if (i === pos) {
                                                        return newitem;
                                                      } else {
                                                        return item;
                                                      }
                                                    }), list)]));
                              }
                              }(fn,pos,list));
                              continue ;
                            } else {
                              throw [
                                    InvalidPath,
                                    path$4
                                  ];
                            }
                          } else {
                            var match$2 = param[1];
                            if (match$2.tag) {
                              var proc = function (_prev, _param) {
                                while(true) {
                                  var param = _param;
                                  var prev = _prev;
                                  var n = param[0];
                                  if (n !== 0) {
                                    var match = param[1];
                                    if (match) {
                                      _param = /* tuple */[
                                        n - 1 | 0,
                                        match[1]
                                      ];
                                      _prev = /* :: */[
                                        match[0],
                                        prev
                                      ];
                                      continue ;
                                    } else {
                                      return prev;
                                    }
                                  } else {
                                    var next = param[1];
                                    if (next) {
                                      var match$1 = next[0];
                                      if (match$1.tag) {
                                        return Pervasives.$at(List.rev(prev), Pervasives.$at(match$1[0], next[1]));
                                      } else {
                                        return Pervasives.$at(List.rev(prev), next);
                                      }
                                    } else {
                                      return Pervasives.$at(List.rev(prev), next);
                                    }
                                  }
                                };
                              };
                              return Curry._1(fn, /* List */Block.__(1, [proc(/* [] */0, /* tuple */[
                                                  pos,
                                                  match$2[0]
                                                ])]));
                            } else {
                              throw [
                                    InvalidPath,
                                    path$4
                                  ];
                            }
                          }
                        } else {
                          return Curry._1(fn, param[1]);
                        }
                      };
                    };
                    var expr = access$4((function (x) {
                            return x;
                          }), /* tuple */[
                          spath$4,
                          data
                        ]);
                    return handleUpdate(/* DirtyUpdate */Block.__(1, [expr]));
                case 6 : 
                    var path$5 = action[0];
                    var spath$5 = List.rev(simplifyPath(data, path$5));
                    var access$5 = function (_fn, _param) {
                      while(true) {
                        var param = _param;
                        var fn = _fn;
                        var match = param[0];
                        if (match) {
                          var match$1 = param[1];
                          var pos = match[0];
                          if (match$1.tag) {
                            var list = match$1[0];
                            _param = /* tuple */[
                              match[1],
                              List.nth(list, pos)
                            ];
                            _fn = (function(fn,pos,list){
                            return function (newitem) {
                              return Curry._1(fn, /* List */Block.__(1, [List.mapi((function (i, item) {
                                                    if (i === pos) {
                                                      return newitem;
                                                    } else {
                                                      return item;
                                                    }
                                                  }), list)]));
                            }
                            }(fn,pos,list));
                            continue ;
                          } else {
                            throw [
                                  InvalidPath,
                                  path$5
                                ];
                          }
                        } else {
                          var src = param[1];
                          if (!src.tag && src[0] === "") {
                            return Curry._1(fn, /* List */Block.__(1, [/* [] */0]));
                          } else {
                            return Curry._1(fn, src);
                          }
                        }
                      };
                    };
                    var expr$1 = access$5((function (x) {
                            return x;
                          }), /* tuple */[
                          spath$5,
                          data
                        ]);
                    return handleUpdate(/* DirtyUpdate */Block.__(1, [expr$1]));
                case 7 : 
                    var text = action[1];
                    var path$6 = action[0];
                    var spath$6 = List.rev(simplifyPath(data, path$6));
                    var access$6 = function (_fn, _param) {
                      while(true) {
                        var param = _param;
                        var fn = _fn;
                        var match = param[0];
                        if (match) {
                          var match$1 = param[1];
                          var pos = match[0];
                          if (match$1.tag) {
                            var list = match$1[0];
                            _param = /* tuple */[
                              match[1],
                              List.nth(list, pos)
                            ];
                            _fn = (function(fn,pos,list){
                            return function (newitem) {
                              return Curry._1(fn, /* List */Block.__(1, [List.mapi((function (i, item) {
                                                    if (i === pos) {
                                                      return newitem;
                                                    } else {
                                                      return item;
                                                    }
                                                  }), list)]));
                            }
                            }(fn,pos,list));
                            continue ;
                          } else {
                            throw [
                                  InvalidPath,
                                  path$6
                                ];
                          }
                        } else if (param[1].tag) {
                          throw [
                                InvalidPath,
                                path$6
                              ];
                        } else {
                          return Curry._1(fn, /* Atom */Block.__(0, [text]));
                        }
                      };
                    };
                    var expr$2 = access$6((function (x) {
                            return x;
                          }), /* tuple */[
                          spath$6,
                          data
                        ]);
                    return handleUpdate(/* DirtyUpdate */Block.__(1, [expr$2]));
                
              }
            }),
          /* subscriptions */component[/* subscriptions */13],
          /* jsElementWrapped */component[/* jsElementWrapped */14]
        ];
}

exports.directionToString = directionToString;
exports.pathListToString = pathListToString;
exports.pathToString = pathToString;
exports.simplifyPath = simplifyPath;
exports.Overflow = Overflow;
exports.InvalidPath = InvalidPath;
exports.component = component;
exports.getValue = getValue;
exports.getValueByFocus = getValueByFocus;
exports.getValueByKeyboard = getValueByKeyboard;
exports.doFocus = doFocus;
exports.selectAll = selectAll;
exports.insertList = insertList;
exports.removeFromList = removeFromList;
exports.pureDebug = pureDebug;
exports.actionDump = actionDump;
exports.make = make;
/* component Not a pure module */
